package com.allanwang.middleware.db.router;


import com.allanwang.middleware.db.router.annotation.DBRouter;
import com.allanwang.middleware.db.router.strategy.IDBRouterStrategy;
import org.apache.commons.lang.StringUtils;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * @description: Data routing cutout to intercept the cutout's methods for database routing by means of custom annotations
 */
@Aspect
public class DBRouterJoinPoint {

    private Logger logger = LoggerFactory.getLogger(DBRouterJoinPoint.class);

    private DBRouterConfig dbRouterConfig;

    private IDBRouterStrategy dbRouterStrategy;

    public DBRouterJoinPoint(DBRouterConfig dbRouterConfig, IDBRouterStrategy dbRouterStrategy) {
        this.dbRouterConfig = dbRouterConfig;
        this.dbRouterStrategy = dbRouterStrategy;
    }

    @Pointcut("@annotation(com.allanwang.middleware.db.router.annotation.DBRouter)")
    public void aopPoint() {
    }

    /**
     * All operations that need to be split into database and table need to be intercepted using custom annotations, and after interception, the incoming fields in the method are read, and routing operations are performed based on the fields.
     * 1. dbRouter.key() determines the routing field. If the annotation is not configured, the default value is used.
     * 2. getAttrValue Based on the database route field, read out the corresponding value from the input parameter. For example, if the route key is uId, then the value of uId is retrieved from the Obj object.
     * 3. dbRouterStrategy.doRouter(dbKeyAttr) Routing policies are processed based on specific routing values
     * 4. Routing processing is done ,that is, released. jp.proceed();
     * 5. dbRouterStrategy needs to execute clear , because ThreadLocal needs to be cleared manually.
     */
    @Around("aopPoint() && @annotation(dbRouter)")
    public Object doRouter(ProceedingJoinPoint jp, DBRouter dbRouter) throws Throwable {
        String dbKey = dbRouter.key();
        if (StringUtils.isBlank(dbKey) && StringUtils.isBlank(dbRouterConfig.getRouterKey())) {
            throw new RuntimeException("annotation DBRouter key is null！");
        }
        dbKey = StringUtils.isNotBlank(dbKey) ? dbKey : dbRouterConfig.getRouterKey();
        // router dbKey attribute
        String dbKeyAttr = getAttrValue(dbKey, jp.getArgs());
        // db router strategy
        dbRouterStrategy.doRouter(dbKeyAttr);
        // return the result
        try {
            return jp.proceed();
        } finally {
            dbRouterStrategy.clear();
        }
    }

    private Method getMethod(JoinPoint jp) throws NoSuchMethodException {
        Signature sig = jp.getSignature();
        MethodSignature methodSignature = (MethodSignature) sig;
        return jp.getTarget().getClass().getMethod(methodSignature.getName(), methodSignature.getParameterTypes());
    }

    public String getAttrValue(String attr, Object[] args) {
        if (1 == args.length) {
            Object arg = args[0];
            if (arg instanceof String) {
                return arg.toString();
            }
        }

        String filedValue = null;
        for (Object arg : args) {
            try {
                if (StringUtils.isNotBlank(filedValue)) {
                    break;
                }
                // filedValue = BeanUtils.getProperty(arg, attr);
                // fix: When using lombok, the get method for a field like uId is different from the get method generated by idea, which will result in not getting the value of the attribute, so change it to reflection to get it.
                filedValue = String.valueOf(this.getValueByName(arg, attr));
            } catch (Exception e) {
                logger.error("Failed to get router attr：{}", attr, e);
            }
        }
        return filedValue;
    }

    /**
     * get a specific attribute value of an object
     *
     * @author tang
     * @param item object
     * @param name attribute name
     * @return attribute value
     */
    private Object getValueByName(Object item, String name) {
        try {
            Field field = getFieldByName(item, name);
            if (field == null) {
                return null;
            }
            field.setAccessible(true);
            Object o = field.get(item);
            field.setAccessible(false);
            return o;
        } catch (IllegalAccessException e) {
            return null;
        }
    }

    /**
     * based on the attribute name, get the corresponding method
     *
     * @author tang
     * @param item object
     * @param name attribute name
     * @return attribute
     */
    private Field getFieldByName(Object item, String name) {
        try {
            Field field;
            try {
                field = item.getClass().getDeclaredField(name);
            } catch (NoSuchFieldException e) {
                field = item.getClass().getSuperclass().getDeclaredField(name);
            }
            return field;
        } catch (NoSuchFieldException e) {
            return null;
        }
    }

}

